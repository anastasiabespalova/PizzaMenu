//
//  MenuWorker.swift
//  PizzaMenu
//
//  Created by Анастасия Беспалова on 11.12.2021.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

enum Categories: String, CaseIterable, Codable {
    case pizza = "pizza"
    case combo = "combo"
    case desserts = "desserts"
    case drinks = "drinks"

    func getRussianName() -> String {
        switch self {
        case .pizza:
            return "Пицца"
        case .combo:
            return "Комбо"
        case .desserts:
            return "Десерты"
        case .drinks:
            return "Напитки"
        }
    }
    
    func getIndex() -> Int {
        switch self {
        case .pizza:
            return 0
        case .combo:
            return 1
        case .desserts:
            return 2
        case .drinks:
            return 3
        }
    }
}

struct ItemDecodable: Codable {
    var name: String
    var price: String
    var composition: String
    var img: String
}

struct ItemRaw: Codable {
    var name: String
    var price: String
    var composition: String
    var img: String
    var category: Categories
    
    init(item: ItemDecodable, category: Categories) {
        self.name = item.name
        self.price = item.price
        self.composition = item.composition
        self.img = item.img
        self.category = category
    }
}

class MenuWorker
{
    
    var rawItems: [ItemRaw] = []
    
    
    func getRawItemsFromAPI() {

        let group = DispatchGroup()
       
        Categories.allCases.forEach { category in
            group.enter()
            DispatchQueue.global(priority: .default).async {
            guard let url = URL(string: "http://127.0.0.1:8000/\(category.rawValue)") else
            {
                return
            }

            var request = URLRequest(url: url)
            request.httpMethod = "get"

            URLSession.shared.dataTask(with: request) { (data, response, error) in
                guard error == nil else { print(error!.localizedDescription); return }
                guard let jsonResult = data else { print("Empty data"); return }
                
                let decoder = JSONDecoder()
                let products = try? decoder
                    .decode(FailableCodableArray<ItemDecodable>.self, from: jsonResult)
                    .elements
                if products != nil {
                    for product in products! {
                        self.rawItems.append(ItemRaw(item: product, category: category))
                    }
                }
                group.leave()
            }.resume()
            }
        }
        
        group.wait()
    }
}


struct FailableDecodable<Base : Decodable> : Decodable {

    let base: Base?

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        self.base = try? container.decode(Base.self)
    }
}


struct FailableCodableArray<Element : Codable> : Codable {

    var elements: [Element]

    init(from decoder: Decoder) throws {

        var container = try decoder.unkeyedContainer()

        var elements = [Element]()
        if let count = container.count {
            elements.reserveCapacity(count)
        }

        while !container.isAtEnd {
            if let element = try container
                .decode(FailableDecodable<Element>.self).base {

                elements.append(element)
            }
        }

        self.elements = elements
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(elements)
    }
}
